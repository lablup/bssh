--- a/src/server/session.rs	2026-01-23 18:47:48
+++ b/src/server/session.rs	2026-01-24 03:08:34
@@ -7,7 +7,7 @@
 use log::debug;
 use negotiation::parse_kex_algo_list;
 use tokio::io::{AsyncRead, AsyncWrite, AsyncWriteExt};
-use tokio::sync::mpsc::{channel, Receiver, Sender};
+use tokio::sync::mpsc::{channel, error::TryRecvError, Receiver, Sender};
 use tokio::sync::oneshot;
 
 use super::*;
@@ -502,10 +502,141 @@
         pin!(reading);
         let mut is_reading = None;
 
+
         #[allow(clippy::panic)] // false positive in macro
         while !self.common.disconnected {
             self.common.received_data = false;
             let mut sent_keepalive = false;
+
+            // BSSH FIX: Process pending messages before entering select!
+            // This ensures messages sent via Handle::data() from spawned tasks
+            // are processed even when select! doesn't wake up for them.
+            // Critical for interactive PTY sessions where shell I/O runs in a separate task.
+            //
+            // We limit the number of messages processed per batch to ensure client input
+            // (e.g., Ctrl+C) is handled promptly even during high-throughput output.
+            const MAX_MESSAGES_PER_BATCH: usize = 64;
+            let mut processed_count = 0usize;
+            if !self.kex.active() {
+                loop {
+                    if processed_count >= MAX_MESSAGES_PER_BATCH {
+                        // Yield to select! to check for client input
+                        break;
+                    }
+                    match self.receiver.try_recv() {
+                        Ok(Msg::Channel(id, ChannelMsg::Data { data })) => {
+                            self.data(id, data)?;
+                            processed_count += 1;
+                        }
+                        Ok(Msg::Channel(id, ChannelMsg::ExtendedData { ext, data })) => {
+                            self.extended_data(id, ext, data)?;
+                            processed_count += 1;
+                        }
+                        Ok(Msg::Channel(id, ChannelMsg::Eof)) => {
+                            self.eof(id)?;
+                            processed_count += 1;
+                        }
+                        Ok(Msg::Channel(id, ChannelMsg::Close)) => {
+                            self.close(id)?;
+                            processed_count += 1;
+                        }
+                        Ok(Msg::Channel(id, ChannelMsg::Success)) => {
+                            self.channel_success(id)?;
+                            processed_count += 1;
+                        }
+                        Ok(Msg::Channel(id, ChannelMsg::Failure)) => {
+                            self.channel_failure(id)?;
+                            processed_count += 1;
+                        }
+                        Ok(Msg::Channel(id, ChannelMsg::XonXoff { client_can_do })) => {
+                            self.xon_xoff_request(id, client_can_do)?;
+                            processed_count += 1;
+                        }
+                        Ok(Msg::Channel(id, ChannelMsg::ExitStatus { exit_status })) => {
+                            self.exit_status_request(id, exit_status)?;
+                            processed_count += 1;
+                        }
+                        Ok(Msg::Channel(id, ChannelMsg::ExitSignal { signal_name, core_dumped, error_message, lang_tag })) => {
+                            self.exit_signal_request(id, signal_name, core_dumped, &error_message, &lang_tag)?;
+                            processed_count += 1;
+                        }
+                        Ok(Msg::Channel(id, ChannelMsg::WindowAdjusted { new_size })) => {
+                            debug!("window adjusted to {new_size:?} for channel {id:?}");
+                            processed_count += 1;
+                        }
+                        Ok(Msg::ChannelOpenAgent { channel_ref }) => {
+                            let id = self.channel_open_agent()?;
+                            self.channels.insert(id, channel_ref);
+                            processed_count += 1;
+                        }
+                        Ok(Msg::ChannelOpenSession { channel_ref }) => {
+                            let id = self.channel_open_session()?;
+                            self.channels.insert(id, channel_ref);
+                            processed_count += 1;
+                        }
+                        Ok(Msg::ChannelOpenDirectTcpIp { host_to_connect, port_to_connect, originator_address, originator_port, channel_ref }) => {
+                            let id = self.channel_open_direct_tcpip(&host_to_connect, port_to_connect, &originator_address, originator_port)?;
+                            self.channels.insert(id, channel_ref);
+                            processed_count += 1;
+                        }
+                        Ok(Msg::ChannelOpenDirectStreamLocal { socket_path, channel_ref }) => {
+                            let id = self.channel_open_direct_streamlocal(&socket_path)?;
+                            self.channels.insert(id, channel_ref);
+                            processed_count += 1;
+                        }
+                        Ok(Msg::ChannelOpenForwardedTcpIp { connected_address, connected_port, originator_address, originator_port, channel_ref }) => {
+                            let id = self.channel_open_forwarded_tcpip(&connected_address, connected_port, &originator_address, originator_port)?;
+                            self.channels.insert(id, channel_ref);
+                            processed_count += 1;
+                        }
+                        Ok(Msg::ChannelOpenForwardedStreamLocal { server_socket_path, channel_ref }) => {
+                            let id = self.channel_open_forwarded_streamlocal(&server_socket_path)?;
+                            self.channels.insert(id, channel_ref);
+                            processed_count += 1;
+                        }
+                        Ok(Msg::ChannelOpenX11 { originator_address, originator_port, channel_ref }) => {
+                            let id = self.channel_open_x11(&originator_address, originator_port)?;
+                            self.channels.insert(id, channel_ref);
+                            processed_count += 1;
+                        }
+                        Ok(Msg::TcpIpForward { address, port, reply_channel }) => {
+                            self.tcpip_forward(&address, port, reply_channel)?;
+                            processed_count += 1;
+                        }
+                        Ok(Msg::CancelTcpIpForward { address, port, reply_channel }) => {
+                            self.cancel_tcpip_forward(&address, port, reply_channel)?;
+                            processed_count += 1;
+                        }
+                        Ok(Msg::Disconnect { reason, description, language_tag }) => {
+                            self.common.disconnect(reason, &description, &language_tag)?;
+                            processed_count += 1;
+                        }
+                        Ok(_) => {
+                            // should be unreachable
+                            processed_count += 1;
+                        }
+                        Err(TryRecvError::Empty) => {
+                            // No more pending messages, proceed to select!
+                            break;
+                        }
+                        Err(TryRecvError::Disconnected) => {
+                            debug!("receiver disconnected");
+                            break;
+                        }
+                    }
+                }
+                // Only flush if we actually processed messages
+                if processed_count > 0 {
+                    self.flush()?;
+                    map_err!(
+                        self.common
+                            .packet_writer
+                            .flush_into(&mut stream_write)
+                            .await
+                    )?;
+                }
+            }
+
             tokio::select! {
                 r = &mut reading => {
                     let (stream_read, mut buffer, mut opening_cipher) = match r {
